<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Ninja Tower 8bit</title>
<style>
  html,body { height:100%; margin:0; background:#000; font-family:system-ui,-apple-system,"Segoe UI",sans-serif; touch-action:none;}
  .wrap { display:grid; place-items:center; height:100%; gap:10px; padding:6px; box-sizing:border-box; }
  canvas { image-rendering: pixelated; image-rendering: crisp-edges; background:#0b2a73; border:4px solid #111; max-width:100%; height:auto; }
  .hud { color:#fff; font-weight:700; text-shadow:0 2px 0 #000; letter-spacing:.5px; display:flex; gap:12px; justify-content:center; flex-wrap:wrap; font-size:14px;}
  .btn { padding:8px 12px; font-weight:700; border:0; cursor:pointer; }

  /* モバイル用パッド */
  .pad { width:100%; max-width:920px; display:flex; justify-content:space-between; gap:12px; user-select:none; }
  .pad-col { flex:1; display:flex; gap:12px; justify-content:center; }
  .dpad { width:180px; height:180px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:10px; }
  .btnc { display:flex; align-items:center; justify-content:center; background:#1d1d1d; color:#fff;
          border:2px solid #444; border-radius:18px; font-weight:800; font-size:16px; min-width:56px; min-height:56px; box-shadow:0 2px 0 #000; }
  .btnc:active{ transform:translateY(1px); }
  .circle { width:86px; height:86px; border-radius:999px; }
  .wide { width:120px; }
  .invis { visibility:hidden; }
  @media (max-width:420px){ .dpad{ width:150px; height:150px; gap:8px; } .circle{ width:74px; height:74px; } .wide{ width:100px; } }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="800" height="450" aria-label="Ninja Tower 8bit game"></canvas>

  <div class="hud" id="hud">
    <span>HI <span id="hiscore">20000</span></span>
    <span>SCORE <span id="score">0</span></span>
    <span>TIME <span id="time">120</span></span>
    <span>残機 <span id="lives">3</span></span>
    <span>←→：移動 / X：ジャンプ / Z：手裏剣 / ↑↓：梯子</span>
    <button class="btn" id="btn">START / RESTART</button>
  </div>

  <!-- タッチパッド -->
  <div class="pad" id="pad">
    <div class="pad-col">
      <div class="dpad">
        <div class="btnc invis"></div>
        <button class="btnc" data-key="arrowup">↑</button>
        <div class="btnc invis"></div>
        <button class="btnc" data-key="arrowleft">←</button>
        <div class="btnc invis"></div>
        <button class="btnc" data-key="arrowright">→</button>
        <div class="btnc invis"></div>
        <button class="btnc" data-key="arrowdown">↓</button>
        <div class="btnc invis"></div>
      </div>
    </div>
    <div class="pad-col" style="gap:18px;">
      <button class="btnc circle" data-key="x" aria-label="Jump">JUMP</button>
      <button class="btnc circle" data-key="z" aria-label="Shuriken">SHURI</button>
    </div>
  </div>
</div>

<script>
(()=>{
// ========= 基本 =========
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
const W = cvs.width, H = cvs.height;
const floorYs = [80, 160, 240, 320]; // 上→下
const gravity = 0.5, friction = 0.85;
const keys = {};
let state = "title"; // title, play, over
let timer = 120, score = 0, hi = 20000, lives = 3, tcount = 0;

document.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key===" "){ e.preventDefault(); }});
document.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });
const startBtn = document.getElementById('btn');
// pointerdownで素早く反応させる
startBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); start(); });

// スクロール防止
['touchstart','touchmove','touchend','gesturestart'].forEach(ev=>{
  document.addEventListener(ev, (e)=>{ if(e.target.closest('#pad') || e.target.closest('#game')) e.preventDefault(); }, {passive:false});
});

// パッド -> keys[] マッピング（Zはタップ即発射）
function bindTouchPad(){
  const buttons = document.querySelectorAll('.btnc[data-key]');
  const setKey = (key, v)=>{ keys[key] = v; };

  buttons.forEach(btn=>{
    const key = btn.dataset.key;
    const onDown = (e)=>{ setKey(key, true); if (key==='z') fire(); }; // 触れた瞬間に1発
    const onUp   = (e)=>{ setKey(key, false); };

    btn.addEventListener('touchstart', onDown, {passive:false});
    btn.addEventListener('mousedown', onDown);
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=> btn.addEventListener(ev, onUp, {passive:false}));
  });

  document.addEventListener('touchend', ()=>{ buttons.forEach(b=> setKey(b.dataset.key,false)); }, {passive:false});
}
bindTouchPad();

function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

// ========= マップ（4層・穴） =========
const platforms = [];
function buildMap(){
  platforms.length = 0;
  const leftPad = 40, rightPad = W-40;
  for(let i=0;i<floorYs.length;i++){
    const y = floorYs[i];
    const holeW = 80;
    const hole1x = 150 + (i*37)%180;
    const hole2x = 430 + (i*53)%220;
    platforms.push({ y, spans:[
      [leftPad, hole1x-10],
      [hole1x+holeW, hole2x-10],
      [hole2x+holeW, rightPad]
    ]});
  }
}
buildMap();

// ========= 梯子 =========
const ladders = [
  {x: 180, y: floorYs[3], h: floorYs[2]-floorYs[3]},
  {x: 400, y: floorYs[2], h: floorYs[1]-floorYs[2]},
  {x: 620, y: floorYs[1], h: floorYs[0]-floorYs[1]}
];

// ========= プレイヤー =========
const player = {
  x: 70, y: floorYs[3]-22, w: 22, h: 22, // hに合わせて-22
  vx: 0, vy: 0, facing: 1, onGround: false, inv: 0,
  onLadder: false
};
function resetPlayer(){
  player.x = 70; player.y = floorYs[3]-22;
  player.vx = 0; player.vy = 0; player.facing = 1; player.onGround=false; player.inv=0; player.onLadder=false;
}

// ========= 敵・弾 =========
const enemies = [];
const shots = [];
function spawnEnemy(){
  if(enemies.length>6) return;
  const f = Math.floor(rand(0,4));
  const dir = Math.random()<0.5? -1:1;
  enemies.push({
    x: dir<0 ? W-60 : 60,
    y: floorYs[f]-18, w: 20, h: 20, vx: dir*1.2, life: 1, floor: f, color: (f%2? "#c090ff":"#ffffff")
  });
}
function fire(){
  if(state!=="play") return;
  if(tcount%8!==0) return; // 連射間隔（8f）
  shots.push({ x: player.x + (player.facing>0? player.w: -4), y: player.y+8, vx: player.facing*5, life: 120 });
}

// ========= アイテム（宝箱） =========
const items = [];
function spawnChest(){
  if(items.length>=2) return;
  const fi = Math.floor(Math.random()*platforms.length);
  const pf = platforms[fi];
  const span = pf.spans[Math.floor(Math.random()*pf.spans.length)];
  const x = Math.floor((span[0] + span[1]) / 2) - 10;
  const y = pf.y - 18;
  const type = Math.random()<0.25 ? "life" : "score";
  items.push({ x, y, w:20, h:16, type, opened:false, life: 60*20 });
}

function hit(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
}

// ========= 描画ユーティリティ =========
function banner(text, y){
  ctx.fillStyle="#00000088"; ctx.fillRect(140, y-30, 520, 60);
  ctx.fillStyle="#ffffff"; ctx.font="32px monospace"; ctx.textAlign="center";
  ctx.fillText(text, W/2, y+6);
}
function small(text, y){
  ctx.fillStyle="#ffffff"; ctx.font="18px monospace"; ctx.textAlign="center";
  ctx.fillText(text, W/2, y);
}

// 社
function drawShrine(x, y){
  ctx.fillStyle = "#2a2a2a"; ctx.fillRect(x, y, 72, 10);
  ctx.fillStyle = "#3d3d3d"; for (let i = 0; i < 9; i++){ ctx.fillRect(x+4+i*8, y-4, 6, 4); }
  ctx.fillStyle = "#1a1a1a"; ctx.fillRect(x+2, y+2, 68, 6);
  ctx.fillStyle = "#8a8a8a"; ctx.fillRect(x+12, y+10, 48, 26);
  ctx.fillStyle = "#6b6b6b"; ctx.fillRect(x+12, y+10, 4, 26); ctx.fillRect(x+56, y+10, 4, 26);
  ctx.fillStyle = "#333";    ctx.fillRect(x+30, y+14, 16, 18);
  ctx.fillStyle = "#bdbdbd"; ctx.fillRect(x+18, y+16, 8, 6); ctx.fillRect(x+50, y+16, 8, 6);
}
// 忍者
function drawNinja(x,y,dir,blink){
  ctx.fillStyle = blink? "#ff5a5a" : "#cc3030";
  ctx.fillRect(x, y, 22, 18); ctx.fillRect(x, y-6, 22, 8);
  ctx.fillStyle="#fff"; if(dir>0){ ctx.fillRect(x+12,y-2,4,2); } else { ctx.fillRect(x+6,y-2,4,2); }
  ctx.fillStyle="#b8b8b8"; ctx.fillRect(x+2, y+18, 6, 4); ctx.fillRect(x+14, y+18, 6, 4);
}
// ゴースト
function drawGhost(x,y,color){
  ctx.fillStyle=color; ctx.fillRect(x, y, 20, 14); ctx.fillRect(x+2, y-6, 16, 8);
  ctx.fillStyle="#000"; ctx.fillRect(x+5, y-2, 3, 3); ctx.fillRect(x+12, y-2, 3, 3);
  ctx.fillStyle=color; ctx.fillRect(x+16, y+6, 8, 3);
}
// 宝箱
function drawChest(x, y, opened, type){
  ctx.fillStyle = "#6e4a2e"; ctx.fillRect(x, y+12, 20, 4);
  ctx.fillStyle = opened ? "#aa7a3a" : "#c18a3f"; ctx.fillRect(x, y, 20, 12);
  ctx.fillStyle = "#ddd"; ctx.fillRect(x+8, y+2, 4, 8);
  ctx.fillStyle = opened ? "#8e642f" : "#7a5327"; ctx.fillRect(x, opened? y-6 : y-4, 20, 4);
  if (!opened){ ctx.fillStyle = (type==="life") ? "#ffef00" : "#ffffff"; ctx.fillRect(x+6, y+5, 8, 2); }
}

// ========= 更新 =========
function update(){
  if(state!=="play") return;

  tcount++;
  if(tcount%60===0 && timer>0){ timer--; document.getElementById('time').textContent = timer; }
  if(timer<=0){ gameOver(); }

  // 入力
  const left = keys['arrowleft'] || keys['a'];
  const right= keys['arrowright']|| keys['d'];
  const up   = keys['arrowup']   || keys['w'];
  const down = keys['arrowdown'] || keys['s'];
  const jump = keys['x'];
  const throwKey = keys['z'];

  if(left){ player.vx -= 0.6; player.facing = -1; }
  if(right){ player.vx += 0.6; player.facing = 1; }
  player.vx = clamp(player.vx, -3, 3);

  // 梯子
  player.onLadder = false;
  for (const lad of ladders) {
    const xMid = player.x + player.w/2;
    const y0 = Math.min(lad.y, lad.y+lad.h);
    const h  = Math.abs(lad.h);
    if (xMid > lad.x && xMid < lad.x+20 && player.y+player.h > y0 && player.y < y0+h) {
      if (up || down) {
        player.onLadder = true;
        player.vy = 0;
        if (up)   player.y -= 2;
        if (down) player.y += 2;
      }
    }
  }

  // 重力
  if (!player.onLadder) player.vy += gravity;

  // 水平移動
  player.x += player.vx;
  player.vx *= player.onGround? friction : 0.98;
  player.x = clamp(player.x, 10, W-10-player.w);

  // 垂直＆足場
  player.onGround = false;
  for(const pf of platforms){
    if(player.vy >= 0 && player.y + player.h <= pf.y && player.y + player.h + player.vy >= pf.y){
      const footL = player.x, footR = player.x + player.w;
      if(pf.spans.some(([sx,ex])=> footR>sx && footL<ex)){
        player.y = pf.y - player.h;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }
  player.y += player.vy;

  // ジャンプ
  if(jump && player.onGround && !player.onLadder){ player.vy = -8; player.onGround=false; }

  // 手裏剣
  if(throwKey) fire();
  for(const s of shots){ s.x += s.vx; s.life--; }
  for(let i=shots.length-1;i>=0;i--){
    if(shots[i].life<=0 || shots[i].x<-20 || shots[i].x>W+20) shots.splice(i,1);
  }

  // 敵出現
  if(tcount%60===0 && Math.random()<0.8) spawnEnemy();

  // 敵AI
  for(const e of enemies){
    e.x += e.vx;
    const pf = platforms[e.floor];
    const onSpan = pf.spans.find(([sx,ex])=> e.x+e.w>sx && e.x<ex);
    if(!onSpan){ e.vx *= -1; e.x += e.vx*2; }
    else{ if(e.x<onSpan[0] || e.x+e.w>onSpan[1]) e.vx*=-1; }
  }

  // 弾ヒット
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    for(let j=shots.length-1;j>=0;j--){
      const s = shots[j];
      if(s.x>e.x-2 && s.x<e.x+e.w+2 && Math.abs(s.y-(e.y+e.h/2))<14){
        enemies.splice(i,1); shots.splice(j,1);
        score += 200; document.getElementById('score').textContent = score;
        break;
      }
    }
  }

  // 敵接触
  if(player.inv>0) player.inv--;
  for(const e of enemies){
    if(hit(player,e) && player.inv<=0){
      lives--; player.inv = 120; resetPlayer();
      document.getElementById('lives').textContent = lives;
      if(lives<=0){ gameOver(); }
      break;
    }
  }

  // 宝箱（10秒ごと）
  if (tcount % (60*10) === 0 && state==="play") spawnChest();

  // アイテム
  for (let i = items.length-1; i >= 0; i--){
    const it = items[i];
    if (!it.opened && player.x < it.x+it.w && player.x+player.w > it.x &&
        player.y < it.y+it.h && player.y+player.h > it.y){
      it.opened = true; it.life = 90;
      if (it.type === "life"){ lives++; document.getElementById('lives').textContent = lives; }
      else { score += 500; document.getElementById('score').textContent = score; }
    }
    it.life--; if (it.life <= 0) items.splice(i,1);
  }
}

// ========= 描画 =========
function draw(){
  ctx.clearRect(0,0,W,H);

  // 瓦ブロック（上縁）
  ctx.fillStyle = "#3b3b3b";
  for(const pf of platforms){
    for(const [sx,ex] of pf.spans){
      for(let x=sx; x<ex; x+=24){ ctx.fillRect(x-2, pf.y-10, 20, 10); }
    }
  }
  // 床
  ctx.fillStyle = "#c9c9c9";
  for(const pf of platforms){
    for(const [sx,ex] of pf.spans){ ctx.fillRect(sx, pf.y, ex-sx, 6); }
  }

  // 梯子
  ctx.fillStyle = "#c09050";
  for (const lad of ladders){
    const y0 = Math.min(lad.y, lad.y+lad.h), h = Math.abs(lad.h);
    ctx.fillRect(lad.x, y0, 4, h); ctx.fillRect(lad.x+16, y0, 4, h);
    for (let step = 0; step < h; step += 8) ctx.fillRect(lad.x, y0+step, 20, 2);
  }

  // 社
  drawShrine(680, floorYs[3]-46);
  drawShrine(40,  floorYs[1]-46);

  // 宝箱
  for (const it of items){ drawChest(it.x, it.y, it.opened, it.type); }

  // 敵
  for(const e of enemies){ drawGhost(e.x, e.y, e.color); }

  // 手裏剣（描画を追加）
  ctx.fillStyle = "#ffd34d";
  for (const s of shots){ ctx.fillRect(s.x - 2, s.y - 2, 4, 4); }

  // プレイヤー
  drawNinja(player.x, player.y, player.facing, player.inv>0 && (tcount%6<3));

  // メッセージ
  if(state==="title"){
    banner("NINJA TOWER 8BIT", H/2-20);
    small("左右←→ / Xジャンプ / Z手裏剣 / ↑↓梯子", H/2+12);
    small("STARTを押してください", H/2+36);
  }else if(state==="over"){
    banner("GAME OVER", H/2-10);
    small("RESTARTで再挑戦", H/2+20);
  }
}

// ========= ループ =========
function loop(){ update(); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// ========= 制御 =========
function start(){
  score=0; timer=120; lives=3; tcount=0;
  enemies.length=0; shots.length=0; items.length=0;
  resetPlayer(); state="play";
  document.getElementById('score').textContent = score;
  document.getElementById('time').textContent = timer;
  document.getElementById('lives').textContent = lives;
  update(); // 1フレーム分更新して確実に床に着地
}
function gameOver(){
  if(state!=="play") return;
  state="over";
  if(score>hi){ hi=score; document.getElementById('hiscore').textContent = hi; }
}
})();
</script>
</body>
</html>
